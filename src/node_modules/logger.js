// IMPORTS /////////////////////////////////////////////////////////////////////

import _                                    from 'lodash';
import semver                               from 'semver';
import * as defaults                        from 'defaults';
import * as levelUtil                       from 'levels';
import codependency                         from 'codependency';
import net                                  from 'net';
import text                                 from 'text';
import tls                                  from 'tls';
import urlUtil                              from 'url';
import build                                from 'serialize';
import { Writable }                           from 'stream';
import {
    BadOptionsError,
    LogentriesError
}   from 'error';
import reconnect_core                       from 'reconnect-core';

// SYMBOLS /////////////////////////////////////////////////////////////////////

const $connection = Symbol('connection property');
const $reconnection = Symbol('reconnection property');
const $reconnect = Symbol('reconnect module');
const $reconnectInitialDelay = Symbol('reconnectionInitialDelay property');
const $reconnectMaxDelay = Symbol('reconnectionMaxDelay property');
const $reconnectBackoffStrategy = Symbol('reconnectBackoffStrategy property');
const $bufferFull = Symbol('bufferFull property');
const $console = Symbol('console property');
const $flatten = Symbol('flatten property');
const $flattenArrays = Symbol('flattenArrays property');
const $getConnection = Symbol('getConnection method');
const $host = Symbol('host property');
const $levels = Symbol('levels property');
const $Logger = Symbol('Logger property (winston / bunyan)');
const $minLevel = Symbol('minLevel property');
const $port = Symbol('port property');
const $replacer = Symbol('replacer property');
const $secure = Symbol('secure property');
const $serialize = Symbol('serialize method');
const $tempLevel = Symbol('tempLevel property (winston)');
const $timeout = Symbol('inactivityTimeout property');
const $timestamp = Symbol('timestamp property');
const $token = Symbol('token property');
const $toLevel = Symbol('toLevel method');
const $withLevel = Symbol('withLevel property');
const $withStack = Symbol('withStack property');

// PATTERNS ////////////////////////////////////////////////////////////////////

const newline = /\n/g;
const tokenPattern = /[a-f\d]{8}-([a-f\d]{4}-){3}[a-f\d]{12}/;

// UTIL ////////////////////////////////////////////////////////////////////////

const finalizeLogString = (log, token) =>
    `${ token } ${ log.toString().replace(newline, '\u2028') }\n`;

const getConsoleMethod = lvl => {
  return lvl == 3 ? 'warn' : lvl > 3 ? 'error' : 'log';
};

const getSafeProp = (log, prop) => {
  while (prop in log) prop = '_' + prop;
  return prop;
};

const requirePeer = codependency.register(module);

// EXPOSED LOGGER EVENTS

module.exports.error_event = 'error';
module.exports.log_event = 'log';
module.exports.connected_event = 'connected';
module.exports.disconnect_event = 'disconnected';
module.exports.timeout_event = 'timed out';
module.exports.drain_writable_event = 'drain';
module.exports.finish_writable_event = 'finish';
module.exports.pipe_writable_event = 'pipe';
module.exports.unpipe_writable_event = 'unpipe';
module.exports.connection_drain_event = 'connection drain';

// LOGGER //////////////////////////////////////////////////////////////////////

export default class Logger extends Writable {
  constructor(opts) {
    super({
      objectMode: true,
      highWaterMark: opts.bufferSize || defaults.bufferSize
    });

    // Sanity checks

    if (_.isUndefined(opts))
      throw new BadOptionsError(opts, text.noOptions());

    if (!_.isObject(opts))
      throw new BadOptionsError(opts, text.optionsNotObj(typeof opts));

    if (_.isUndefined(opts.token))
      throw new BadOptionsError(opts, text.noToken());

    if (!_.isString(opts.token) || !tokenPattern.test(opts.token))
      throw new BadOptionsError(opts, text.invalidToken(opts.token));

    // Log method aliases

    this[$levels] = levelUtil.normalize(opts);

    for (const lvlName of this.levels) {
      if (lvlName in this)
        throw new BadOptionsError(opts, text.levelConflict(lvlName));

      Object.defineProperty(this, lvlName, {
        enumerable: true,
        writable: false,
        value() {
          this.log.apply(this, [lvlName, ...arguments]);
        }
      });
    }

    // Other permanent options

    this[$token] = opts.token;

    // Editable options

    const secure = opts.secure === undefined ? defaults.secure : opts.secure;

    this.port = opts.port || (secure ? defaults.portSecure : defaults.port);
    this.flatten = opts.flatten;
    this.flattenArrays = 'flattenArrays' in opts ? opts.flattenArrays : opts.flatten;
    this.json = opts.json;
    this.host = opts.host;
    this.console = opts.console;
    this.minLevel = opts.minLevel;
    this.replacer = opts.replacer;
    this.inactivityTimeout = opts.inactivityTimeout || defaults.inactivityTimeout;
    this.timestamp = opts.timestamp;
    this.withLevel = 'withLevel' in opts ? opts.withLevel : true;
    this.withStack = opts.withStack;
    this[$secure] = secure;
    this[$reconnectInitialDelay] = opts.reconnectInitialDelay || defaults.reconnectInitialDelay;
    this[$reconnectMaxDelay] = opts.reconnectMaxDelay || defaults.reconnectMaxDelay;
    this[$reconnectBackoffStrategy] = opts.reconnectBackoffStrategy || defaults.reconnectBackoffStrategy;
    this.debugEnabled = opts.debug || false;

    if (!this.debugEnabled) {
      //if there is no debug set, empty logger should be used
      this.debugLogger = {
        log: () => {
        }
      };
    } else {
      this.debugLogger = (opts.debugLogger && opts.debugLogger.log) ? opts.debugLogger : defaults.debugLogger;
    }

    this[$reconnect] = reconnect_core(function () {
      var connection;
      if (secure) {
        connection = tls.connect.apply(tls, arguments, () => {
          if (!connection.authorized) {
            this.debugLogger.log('Secure connection -TLS- is not authorized.');
            const errMsg = connection.authorizationError;
            this.emit(new LogentriesError(text.authError(errMsg)));
          } else if (tls && tls.CleartextStream && connection instanceof tls.CleartextStream) {
            this.emit('connect');
          }
        });
      } else {
        connection = net.connect.apply(null, arguments);
      }

      connection.setTimeout(opts.inactivityTimeout || defaults.inactivityTimeout);
      // Expose the connectionâ€™s drain event
      connection.on('drain', () => {
        setImmediate(() => this.emit('connection drain'));
      });

      connection.on('connect', () => {
        this.emit('connected');
      });

      connection.on('disconnect', () => {
        this.emit('disconnected')
      });

      return connection;
    });
  }

  // Stream methods

  _write(log, enc, cb) {
    log = finalizeLogString(log, this[$token]);

    this[$getConnection]().then(conn => {
      conn.write(log);
    }).catch(err => {
      this.emit('error', err);
      this.debugLogger.log('Error: ' + err);
    });

    cb();
  }

  end() {
    this.on('connection drain', () => this.closeConnection());
    super.end(...arguments);
  }

  setDefaultEncoding() { /* no. */
  }

  // Public methods
  log(lvl, log) {
    // lvl is optional
    if (log === undefined) {
      log = lvl;
      lvl = null;
    }

    let lvlName;

    if (lvl || lvl === 0) {
      [lvl, lvlName] = this[$toLevel](lvl);

      // If lvl is present, it must be recognized
      if (!lvl && lvl !== 0) {
        this.emit('error', new LogentriesError(text.unknownLevel(lvl)));
        return;
      }

      // If lvl is below minLevel, it is dismissed
      if (lvl < this.minLevel)
        return;
    }

    // If log is an array, it is treated as a collection of log events
    if (_.isArray(log)) {
      if (log.length)
        for (const $log of log) this.log(lvl, $log);
      else
        this.emit('error', new LogentriesError(text.noLogMessage()));

      return;
    }

    // If log is an object, it is serialized to string and may be augmented
    // with timestamp and level. For strings, these may be prepended.

    if (_.isObject(log)) {

      let safeTime, safeLevel;

      if (this.timestamp) {
        safeTime = getSafeProp(log, 'time');
        log[safeTime] = new Date();
      }

      if (this.withLevel && lvlName) {
        safeLevel = getSafeProp(log, 'level');
        log[safeLevel] = lvlName;
      }

      log = this[$serialize](log);

      if (!log) {
        this.emit('error', new LogentriesError(text.serializedEmpty()));
        return;
      }

      if (this.console)
        console[getConsoleMethod(lvl)](JSON.parse(log));

      if (safeTime) delete log[safeTime];
      if (safeLevel) delete log[safeLevel];

    } else {
      if (_.isEmpty(log)) {
        this.emit('error', new LogentriesError(text.noLogMessage()));
        return;
      }

      log = [log.toString()];

      if (this.withLevel && lvlName)
        log.unshift(lvlName);

      if (this.timestamp)
        log.unshift((new Date()).toISOString());

      log = log.join(' ');

      if (this.console)
        console[getConsoleMethod(lvl)](log);
    }

    if (this[$bufferFull]) {
      this.debugLogger.log('Returning, buffer is full.');
      this.emit('error', new LogentriesError(text.bufferFull(log)));
      return;
    }

    this.emit('log', log);

    const mayWriteFurther = this.write(log);

    if (!mayWriteFurther) {
      this.debugLogger.log('Cannot write further to this stream.');
      this[$bufferFull] = true;
      this.once('drain', () => {
        this[$bufferFull] = false;
      });
    }
  }

  closeConnection() {
    this.debugLogger.log('Closing retry mechanism along with its connection.');

    if (!this[$reconnection]) {
      return;
    }
    // this makes sure retry mechanism and connection will be closed.
    this[$reconnection].disconnect();
  }

  // Private methods

  [$toLevel](val) {
    let num;

    if (levelUtil.isNumberValid(val))
      num = parseInt(parseInt(val)); // -0
    else
      num = this[$levels].indexOf(val);

    const name = this[$levels][num];

    return name ? [num, name] : [];
  }

  [$getConnection]() {
    // The $connection property is a promise. On error, manual close, or
    // inactivityTimeout, it deletes itself.

    if (this[$connection]) {
      return this[$connection];
    } else {
      this.debugLogger.log('No connection exists. Creating a new one.');
      return this.getConnectionPromise();
    }
  }

  getConnectionPromise() {
    // clear the state of previous reconnection and create a new one with a new connection promise.
    if (this[$reconnection]) {
      // destroy previous reconnect instance if it exists.
      this[$reconnection].disconnect();
      delete this[$reconnection];
    }

    this[$reconnection] = this[$reconnect]({
      // all options are optional
      initialDelay: this.reconnectInitialDelay,
      maxDelay: this.reconnectMaxDelay,
      strategy: this.reconnectBackoffStrategy,
      failAfter: Infinity,
      randomisationFactor: 0,
      immediate: false
    });

    this[$connection] = new Promise((resolve, reject) => {
      const debugLogger = this.debugLogger;
      const connOpts = {
        host: this.host,
        port: this.port
      };

      this[$reconnection].on('connect', function (con) {
        debugLogger.log('Connected');
        this.emit('connected');
        con.on('timeout', () => {
          //we listen to timeout event and close connection if it happens. see below.
          this.emit('connection timeout');
        });
        resolve(con);
      });

      this[$reconnection].on('reconnect', function (n, delay) {
        if (n > 0) {
          debugLogger.log(`Trying to reconnect. Times: ${n}, previous delay: ${delay}`);
        }
      });

      this[$reconnection].on('disconnect', function () {
        debugLogger.log('Disconnected.');
        this.emit('disconnected');
      });

      this[$reconnection].on('error', function (err) {
        debugLogger.log('Error occurred during connection: ' + err);
      });

      // now try to connect
      this[$reconnection].connect(connOpts);
    });

    this[$reconnection].on('connection timeout', () => {
      // we owe a lot to inactivity timeout handling with regards to clearing unwanted opened connections hanging around.
      this.debugLogger.log('Socket was inactive for a period of time. Destroying.');
      this.closeConnection();
      delete this[$connection];
      this.emit('timed out');
    });

    this[$reconnection].once('disconnected', () => {
      // Destroying broken promise. We don't need it anymore. This bitter earth.
      delete this[$connection];
    });

    return this[$connection];
  }

  // Coercive settable options

  get console() {
    return this[$console];
  }

  set console(val) {
    this[$console] = !!val;
  }

  get flatten() {
    return this[$flatten];
  }

  set flatten(val) {
    this[$flatten] = !!val;
    this[$serialize] = build(this);
  }

  get flattenArrays() {
    return this[$flattenArrays];
  }

  set flattenArrays(val) {
    this[$flattenArrays] = !!val;
    this[$serialize] = build(this);
  }

  get host() {
    return this[$host];
  }

  set host(val) {
    if (!_.isString(val) || !val.length) {
      this[$host] = defaults.host;
      return;
    }

    val = val.replace(/^https?:\/\//, '');

    const url = urlUtil.parse(`http://${ val }`);

    this[$host] = url.hostname || defaults.host;

    if (url.port) this.port = url.port;
  }

  get reconnect() {
    return this[$reconnect];
  }

  get reconnectMaxDelay() {
    return this[$reconnectMaxDelay];
  }

  get reconnectInitialDelay() {
    return this[$reconnectInitialDelay];
  }

  get reconnectBackoffStrategy() {
    return this[$reconnectBackoffStrategy];
  }

  get minLevel() {
    return this[$minLevel];
  }

  set minLevel(val) {
    const [num] = this[$toLevel](val);

    this[$minLevel] = _.isNumber(num) ? num : 0;
  }

  get port() {
    return this[$port];
  }

  set port(val) {
    val = parseFloat(val);
    if (Number.isInteger(val) && _.inRange(val, 65536)) this[$port] = val;
  }

  get replacer() {
    return this[$replacer];
  }

  set replacer(val) {
    this[$replacer] = _.isFunction(val) ? val : undefined;
    this[$serialize] = build(this);
  }

  get inactivityTimeout() {
    return this[$timeout];
  }

  set inactivityTimeout(val) {
    if (Number.isInteger(val) && val >= 0) {
      this[$timeout] = parseInt(val);
    }

    if (!_.isNumber(this[$timeout])) {
      this[$timeout] = defaults.inactivityTimeout;
    }
  }

  get timestamp() {
    return this[$timestamp];
  }

  set timestamp(val) {
    this[$timestamp] = !!val;
  }

  get withLevel() {
    return this[$withLevel];
  }

  set withLevel(val) {
    this[$withLevel] = !!val;
  }

  get withStack() {
    return this[$withStack];
  }

  set withStack(val) {
    this[$withStack] = !!val;
    this[$serialize] = build(this);
  }

  get connection() {
    return this[$connection];
  }

  // Immutable properties

  get levels() {
    return this[$levels] && this[$levels].slice();
  }

  get secure() {
    return this[$secure];
  }

  // Exposed but externally immutable

  get serialize() {
    return this[$serialize];
  }

  // Deprecated (to support migrants from le_node)

  level(name) {
    console.warn(text.deprecatedLevelMethod());
    if (~this[$levels].indexOf(name)) this.minLevel = name;
  }

  winston() {
    console.warn(text.deprecatedWinstonMethod());
  }

  // Static methods

  static provisionWinston(winston) {

    if (winston.transports.Logentries) return;

    const Transport = winston.Transport;

    class LogentriesTransport extends Transport {
      constructor(opts) {
        super(opts);
        this.json = opts.json;

        opts = _.clone(opts || {});

        opts.minLevel =
            opts.minLevel || opts.level || this[$tempLevel] || 0;

        opts.levels = opts.levels || winston.levels;
        if (semver.satisfies(winston.version, '>=2.0.0')) {
          // Winston and Logengries levels are reversed
          // ('error' level is 0 for Winston and 5 for Logentries)
          // If the user provides custom levels we assue they are
          // using winston standard
          const levels = opts.levels;
          const values = _.values(levels).reverse();
          opts.levels = {};
          _.keys(levels).forEach((k, i) => {
            opts.levels[k] = values[i];
          });
        }

        delete this[$tempLevel];

        this[$Logger] = new Logger(opts);

        this[$Logger].on('error', err => this.emit(err));
      }

      log(lvl, msg, meta, cb) {
        if (this.json) {
          const message = {
            message: msg
          };
          if (!_.isEmpty(meta)) {
            if (_.isObject(meta))
              _.defaults(message, meta);
            else
              message.meta = meta;
          }

          this[$Logger].log(lvl, message);
        } else {
          if (!_.isEmpty(meta)) {
            if (_.isString(msg))
              msg += ' ' + this[$Logger][$serialize](meta);

            else if (_.isObject(msg))
              msg[getSafeProp(msg, 'meta')] = meta;
          }

          this[$Logger].log(lvl, msg);
        }

        setImmediate(cb.bind(null, null, true));
      }

      get name() {
        return 'logentries';
      }

      get level() {
        const [ , lvlName ] =
            this[$Logger][$toLevel](this[$Logger].minLevel);
        return lvlName;
      }

      set level(val) {
        if (!this[$Logger])
          this[$tempLevel] = val;
        else
          this[$Logger].minLevel = val;
      }

      get levels() {
        return this[$Logger].levels.reduce((acc, lvlName, lvlNum) => {
          acc[lvlName] = lvlNum;
          return acc;
        }, {});
      }
    }

    winston.transports.Logentries = LogentriesTransport;
  }

  static bunyanStream(opts) {
    const stream = new BunyanStream(opts);
    const [ , level ] = stream[$Logger][$toLevel](stream[$Logger].minLevel);
    const type = 'raw';
    const name = 'logentries';

    // Defer to Bunyanâ€™s handling of minLevel

    stream[$Logger].minLevel = 0;

    return { level, name, stream, type };
  }
}

// PROVISION WINSTON ///////////////////////////////////////////////////////////

const winston = requirePeer('winston', { optional: true });

if (winston) Logger.provisionWinston(winston);

// Provision too the winston static versions for testing/development purposes
const winston1 = requirePeer('winston1', { optional: true });
const winston2 = requirePeer('winston2x', { optional: true });

if (winston1) Logger.provisionWinston(winston1);
if (winston2) Logger.provisionWinston(winston2);

// BUNYAN STREAM ///////////////////////////////////////////////////////////////

class BunyanStream extends Writable {
  constructor(opts) {
    super({
      objectMode: true,
      highWaterMark: opts.bufferSize || defaults.bufferSize
    });

    opts = _.clone(opts || {});

    opts.timestamp = false;
    opts.levels = opts.levels || defaults.bunyanLevels;

    this[$Logger] = new Logger(opts);

    this[$Logger].on('error', err => this.emit(err));
  }

  _write(log, enc, cb) {
    const lvl = (log.level / 10) - 1;

    this[$Logger].log(lvl, log);

    setImmediate(cb);
  }
}