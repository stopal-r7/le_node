// IMPORTS /////////////////////////////////////////////////////////////////////

import _                                    from 'lodash';
import semver                               from 'semver';
import * as defaults                        from 'defaults';
import * as levelUtil                       from 'levels';
import codependency                         from 'codependency';
import net                                  from 'net';
import text                                 from 'text';
import tls                                  from 'tls';
import urlUtil                              from 'url';
import {build}                              from 'serialize';
import {Writable}                           from 'stream';
import {BadOptionsError, LogentriesError}   from 'error';
import reconnect_core                       from 'reconnect-core';

// SYMBOLS /////////////////////////////////////////////////////////////////////

const $bufferFull               = Symbol('bufferFull property');
const $connection               = Symbol('connection property');
const $reconnection             = Symbol('reconnection property');
const $reconnect                = Symbol('reconnect property');
const $console                  = Symbol('console property');
const $flatten                  = Symbol('flatten property');
const $flattenArrays            = Symbol('flattenArrays property');
const $getConnection            = Symbol('getConnection method');
const $host                     = Symbol('host property');
const $levels                   = Symbol('levels property');
const $Logger                   = Symbol('Logger property (winston / bunyan)');
const $minLevel                 = Symbol('minLevel property');
const $port                     = Symbol('port property');
const $replacer                 = Symbol('replacer property');
const $reconnectionInitialDelay = Symbol('reconnectionInitialDelay property');
const $reconnectionMaxDelay     = Symbol('reconnectionMaxDelay property');
const $secure                   = Symbol('secure property');
const $serialize                = Symbol('serialize method');
const $tempLevel                = Symbol('tempLevel property (winston)');
const $timeout                  = Symbol('timeout property');
const $timestamp                = Symbol('timestamp property');
const $token                    = Symbol('token property');
const $toLevel                  = Symbol('toLevel method');
const $withLevel                = Symbol('withLevel property');
const $withStack                = Symbol('withStack property');

// PATTERNS ////////////////////////////////////////////////////////////////////

const newline      = /\n/g;
const tokenPattern = /[a-f\d]{8}-([a-f\d]{4}-){3}[a-f\d]{12}/;

// UTIL ////////////////////////////////////////////////////////////////////////

const finalizeLogString = (log, token) =>
	`${ token } ${ log.toString().replace(newline, '\u2028') }\n`;

const getConsoleMethod = lvl => {
	return lvl == 3 ? 'warn' : lvl > 3 ? 'error' : 'log';
};

const getSafeProp = (log, prop) => {
	while (prop in log) prop = '_' + prop;
	return prop;
};

const requirePeer = codependency.register(module);

// DECORATORS //////////////////////////////////////////////////////////////////

const nonConfigurable = (target, name, descriptor) => {
	descriptor.configurable = false;
	descriptor.enumerable   = true;
	return descriptor;
};

const unwritable = (target, name, descriptor) => {
	descriptor.writable = false;
	return descriptor;
};

const enumerable = (target, name, descriptor) => {
	descriptor.enumerable = true;
	return descriptor;
};

var DEBUG = (function () {
	var timestamp      = function () {
	};
	timestamp.toString = function () {
		return "[DEBUG " + (new Date).toLocaleString() + "]";
	};

	return {
		log: console.log.bind(console, '%s', timestamp)
	}
})();

// LOGGER //////////////////////////////////////////////////////////////////////

export default class Logger extends Writable {
	constructor(opts) {
		super({
			objectMode: true,
			highWaterMark: opts.bufferSize || defaults.bufferSize
		});

		// Sanity checks

		if (_.isUndefined(opts))
			throw new BadOptionsError(opts, text.noOptions());

		if (!_.isObject(opts))
			throw new BadOptionsError(opts, text.optionsNotObj(typeof opts));

		if (_.isUndefined(opts.token))
			throw new BadOptionsError(opts, text.noToken());

		if (!_.isString(opts.token) || !tokenPattern.test(opts.token))
			throw new BadOptionsError(opts, text.invalidToken(opts.token));

		// Log method aliases

		this[$levels] = levelUtil.normalize(opts);

		for (const lvlName of this.levels) {
			if (lvlName in this)
				throw new BadOptionsError(opts, text.levelConflict(lvlName));

			Object.defineProperty(this, lvlName, {
				enumerable: true,
				writable: false,
				value() {
					this.log.apply(this, [lvlName, ...arguments]);
				}
			});
		}

		// Other permanent options

		this[$token] = opts.token;

		// Editable options

		this.port =
			opts.port || (opts.secure ? defaults.portSecure : defaults.port);

		this.flatten       = opts.flatten;
		this.flattenArrays =
			'flattenArrays' in opts ? opts.flattenArrays : opts.flatten;

		this.json                       = opts.json;
		this.host                       = opts.host;
		this.console                    = opts.console;
		this.minLevel                   = opts.minLevel;
		this.replacer                   = opts.replacer;
		this.timeout                    = opts.timeout || defaults.timeout;
		this.timestamp                  = opts.timestamp;
		this.withLevel                  = 'withLevel' in opts ? opts.withLevel : true;
		this.withStack                  = opts.withStack;
		this[$secure]                   = opts.secure;
		this[$reconnectionInitialDelay] = opts.reconnectionInitialDelay || defaults.reconnectionInitialDelay;
		this[$reconnectionMaxDelay]     = opts.reconnectionMaxDelay || defaults.reconnectionMaxDelay;

		this[$reconnect] = reconnect_core(function () {
			let connection;
			if (opts.secure) {
				DEBUG.log("Secure connection flag found. Creating a secure connection.");
				connection = tls.connect.apply(null, arguments, () => {
					if (!connection.authorized) {
						DEBUG.log("Secure connection -TLS- authorized. Proceeding.");
						const errMsg = connection.authorizationError;
						this.emit(new LogentriesError(text.authError(errMsg)));
					} else if (tls && tls.CleartextStream &&
						connection instanceof tls.CleartextStream)
					// Your node is ancient!
						this.emit('connect');
				});
			} else {
				connection = net.connect.apply(null, arguments);
				connection.setTimeout(defaults.timeout);
			}

			// Expose the connection’s drain event
			connection.on('drain', () =>
				setImmediate(() => this.emit('connection drain'))
			);

			return connection;
		});
	}

	// Stream methods

	@unwritable
	async _write(log, enc, cb) {
		log = finalizeLogString(log, this[$token]);

		try {
			const conn = await this[$getConnection]();
			conn.write(log);
		} catch (err) {
			this.emit('error', err);
			DEBUG.log("Error: " + err);
		} finally {
			cb();
		}
	}

	@unwritable
	end() {
		this.on('connection drain', () => this.closeConnection());
		super.end(...arguments);
	}

	@unwritable
	setDefaultEncoding() { /* no. */
	}

	// Public methods

	@unwritable
	@enumerable
	log(lvl, log) {
		// lvl is optional
		if (log === undefined) {
			log = lvl;
			lvl = null;
		}

		let lvlName;

		if (lvl || lvl === 0) {
			[lvl, lvlName] = this[$toLevel](lvl);

			// If lvl is present, it must be recognized
			if (!lvl && lvl !== 0) {
				this.emit('error', new LogentriesError(text.unknownLevel(lvl)));
				return;
			}

			// If lvl is below minLevel, it is dismissed
			if (lvl < this.minLevel)
				return;
		}

		// If log is an array, it is treated as a collection of log events
		if (_.isArray(log)) {
			if (log.length)
				for (const $log of log) this.log(lvl, $log);
			else
				this.emit('error', new LogentriesError(text.noLogMessage()));

			return;
		}

		// If log is an object, it is serialized to string and may be augmented
		// with timestamp and level. For strings, these may be prepended.

		if (_.isObject(log)) {

			let safeTime, safeLevel;

			if (this.timestamp) {
				safeTime      = getSafeProp(log, 'time');
				log[safeTime] = new Date();
			}

			if (this.withLevel && lvlName) {
				safeLevel      = getSafeProp(log, 'level');
				log[safeLevel] = lvlName;
			}

			log = this[$serialize](log);

			if (!log) {
				this.emit('error', new LogentriesError(text.serializedEmpty()));
				return;
			}

			if (this.console)
				console[getConsoleMethod(lvl)](JSON.parse(log));

			if (safeTime) delete log[safeTime];
			if (safeLevel) delete log[safeLevel];

		} else {
			if (_.isEmpty(log)) {
				this.emit('error', new LogentriesError(text.noLogMessage()));
				return;
			}

			log = [log.toString()];

			if (this.withLevel && lvlName)
				log.unshift(lvlName);

			if (this.timestamp)
				log.unshift((new Date()).toISOString());

			log = log.join(' ');

			if (this.console)
				console[getConsoleMethod(lvl)](log);
		}

		if (this[$bufferFull]) {
			DEBUG.log("Returning, buffer is full.");
			//this.emit('error', new LogentriesError(text.bufferFull(log)));
			return;
		}

		this.emit('log', log);

		const mayWriteFurther = this.write(log);

		if (!mayWriteFurther) {
			DEBUG.log("Cannot write further to this stream.");
			this[$bufferFull] = true;
			this.once('drain', () => {
				DEBUG.log("Writable drained.");
				this[$bufferFull] = false;
			});
		}
	}


	@unwritable
	@enumerable
	closeConnection() {
		DEBUG.log("Closing connection and retries.");
		if (!this[$connection])
			return;

		if (!this[$reconnection])
			return;

		this[$reconnection].disconnect();
	}

	// Private methods

	[$toLevel](val) {
		let num;

		if (levelUtil.isNumberValid(val))
			num = parseInt(parseInt(val)); // -0
		else
			num = this[$levels].indexOf(val);

		const name = this[$levels][num];

		return name ? [num, name] : [];
	}

	async [$getConnection]() {

		// The $connection property is a promise. On error, manual close, or
		// timeout, it deletes itself.

		if (this[$connection]) {
			var conn = await this[$connection];

			if (!conn.destroyed) {
				return this[$connection];
			} else {
				DEBUG.log("Found a connection but it is disconnected.");
				return this.prepareConnectionPromise();
			}
		} else {
			DEBUG.log("No connection found. Creating a new one.");
			return this.prepareConnectionPromise();
		}
	}

	prepareConnectionPromise() {
		if (this[$reconnection]) {
			// destroy previous reconnect instance
			this[$reconnection].disconnect();
			delete this[$reconnection];

			// make sure previous connection is destroyed before creating a new one.
			if (this[$connection]) {
				DEBUG.log("Deleting connection: " + this[$connection]);
				delete this[$connection];
			}
		}

		this[$reconnection] = this[$reconnect]({
			// all options are optional
			initialDelay: this.reconnectionInitialDelay,
			maxDelay: this.reconnectionMaxDelay,
			strategy: 'fibonacci',
			failAfter: Infinity,
			randomisationFactor: 0,
			immediate: false
		}, function (stream) {
			//DEBUG.log("Stream received: " + stream.toString())
		});

		this[$connection] = new Promise((resolve, reject) => {
			DEBUG.log("Making a new connection promise.");
			const opts = {
				host: this.host,
				port: this.port
			};

			this[$reconnection].on('connect', function (con) {
				DEBUG.log("Connected");
				this.emit('connected');
				resolve(con);
			});

			this[$reconnection].on('reconnect', function (n, delay) {
				if (n > 0)
					DEBUG.log("Reconnection times: " + n + " , previous delay: " + delay);
			});

			this[$reconnection].on('disconnect', function () {
				DEBUG.log("Disconnected.");
				this.emit('disconnected');
			});

			this[$reconnection].on('error', function (err) {
				DEBUG.log("Error occurred: " + err);
			});

			// trigger connection
			this[$reconnection].connect(opts);
		});

		return this[$connection];
	}

	// Coercive settable options

	@nonConfigurable
	get console() {
		return this[$console];
	}

	set console(val) {
		this[$console] = !!val;
	}

	@nonConfigurable
	get flatten() {
		return this[$flatten];
	}

	set flatten(val) {
		this[$flatten]   = !!val;
		this[$serialize] = build(this);
	}

	@nonConfigurable
	get flattenArrays() {
		return this[$flattenArrays];
	}

	set flattenArrays(val) {
		this[$flattenArrays] = !!val;
		this[$serialize]     = build(this);
	}

	@nonConfigurable
	get host() {
		return this[$host];
	}

	set host(val) {
		if (!_.isString(val) || !val.length) {
			this[$host] = defaults.host;
			return;
		}

		val = val.replace(/^https?:\/\//, '');

		const url = urlUtil.parse(`http://${ val }`);

		this[$host] = url.hostname || defaults.host;

		if (url.port) this.port = url.port;
	}

	@nonConfigurable
	get reconnect() {
		return this[$reconnect];
	}

	@nonConfigurable
	get reconnectionMaxDelay() {
		return this[$reconnectionMaxDelay];
	}

	@nonConfigurable
	get reconnectionInitialDelay() {
		return this[$reconnectionInitialDelay];
	}

	@nonConfigurable
	get minLevel() {
		return this[$minLevel];
	}

	set minLevel(val) {
		const [ num ] = this[$toLevel](val);

		this[$minLevel] = _.isNumber(num) ? num : 0;
	}

	@nonConfigurable
	get port() {
		return this[$port];
	}

	set port(val) {
		val = parseFloat(val);
		if (Number.isInteger(val) && _.inRange(val, 65536)) this[$port] = val;
	}

	@nonConfigurable
	get replacer() {
		return this[$replacer];
	}

	set replacer(val) {
		this[$replacer]  = _.isFunction(val) ? val : undefined;
		this[$serialize] = build(this);
	}

	@nonConfigurable
	get timeout() {
		return this[$timeout];
	}

	set timeout(val) {
		if (Number.isInteger(val) && val >= 0)
			this[$timeout] = parseInt(val);

		if (!_.isNumber(this[$timeout]))
			this[$timeout] = defaults.timeout;

	}

	@nonConfigurable
	get timestamp() {
		return this[$timestamp];
	}

	set timestamp(val) {
		this[$timestamp] = !!val;
	}

	@nonConfigurable
	get withLevel() {
		return this[$withLevel];
	}

	set withLevel(val) {
		this[$withLevel] = !!val;
	}

	@nonConfigurable
	get withStack() {
		return this[$withStack];
	}

	set withStack(val) {
		this[$withStack] = !!val;
		this[$serialize] = build(this);
	}

	@nonConfigurable
	get connection() {
		return this[$connection];
	}

	set connection(val) {
		this[$connection] = !!val;
	}

	// Immutable properties

	@nonConfigurable
	get levels() {
		return this[$levels] && this[$levels].slice();
	}

	@nonConfigurable
	get secure() {
		return this[$secure];
	}

	// Exposed but externally immutable

	@nonConfigurable
	get serialize() {
		return this[$serialize];
	}

	// Deprecated (to support migrants from le_node)

	@unwritable
	level(name) {
		console.warn(text.deprecatedLevelMethod());
		if (~this[$levels].indexOf(name)) this.minLevel = name;
	}

	@unwritable
	winston() {
		console.warn(text.deprecatedWinstonMethod());
	}

	// Static methods

	@unwritable
	static provisionWinston(winston) {

		if (winston.transports.Logentries) return;

		const Transport = winston.Transport;

		class LogentriesTransport extends Transport {
			constructor(opts) {
				super(opts);
				this.json = opts.json;

				opts = _.clone(opts || {});

				opts.minLevel =
					opts.minLevel || opts.level || this[$tempLevel] || 0;

				opts.levels = opts.levels || winston.levels;
				if (semver.satisfies(winston.version, '>=2.0.0')) {
					// Winston and Logengries levels are reversed
					// ('error' level is 0 for Winston and 5 for Logentries)
					// If the user provides custom levels we assue they are
					// using winston standard
					const levels = opts.levels;
					const values = _.values(levels).reverse();
					opts.levels  = {};
					_.keys(levels).forEach((k, i) => {
						opts.levels[k] = values[i];
					});
				}

				delete this[$tempLevel];

				this[$Logger] = new Logger(opts);

				this[$Logger].on('error', err => this.emit(err));
			}

			@unwritable
			@enumerable
			log(lvl, msg, meta, cb) {
				if (this.json) {
					const message = {
						message: msg
					};
					if (!_.isEmpty(meta)) {
						if (_.isObject(meta))
							_.defaults(message, meta);
						else
							message.meta = meta;
					}

					this[$Logger].log(lvl, message);
				} else {
					if (!_.isEmpty(meta)) {
						if (_.isString(msg))
							msg += ' ' + this[$Logger][$serialize](meta);

						else if (_.isObject(msg))
							msg[getSafeProp(msg, 'meta')] = meta;
					}

					this[$Logger].log(lvl, msg);
				}

				setImmediate(cb.bind(null, null, true));
			}

			@nonConfigurable
			get name() {
				return 'logentries';
			}

			@nonConfigurable
			get level() {
				const [ , lvlName ] =
					      this[$Logger][$toLevel](this[$Logger].minLevel);

				return lvlName;
			}

			set level(val) {
				if (!this[$Logger])
					this[$tempLevel] = val;
				else
					this[$Logger].minLevel = val;
			}

			@nonConfigurable
			get levels() {
				return this[$Logger].levels.reduce((acc, lvlName, lvlNum) => {
					acc[lvlName] = lvlNum;
					return acc;
				}, {});
			}
		}

		winston.transports.Logentries = LogentriesTransport;
	}

	static bunyanStream(opts) {
		const stream = new BunyanStream(opts);
		const [ , level ] = stream[$Logger][$toLevel](stream[$Logger].minLevel);
		const type   = 'raw';
		const name   = 'logentries';

		// Defer to Bunyan’s handling of minLevel

		stream[$Logger].minLevel = 0;

		return {level, name, stream, type};
	}
}

// PROVISION WINSTON ///////////////////////////////////////////////////////////

const winston = requirePeer('winston', {optional: true});

if (winston) Logger.provisionWinston(winston);

// Provision too the winston static versions for testing/development purposes
const winston1 = requirePeer('winston1', {optional: true});
const winston2 = requirePeer('winston2x', {optional: true});

if (winston1) Logger.provisionWinston(winston1);
if (winston2) Logger.provisionWinston(winston2);

// BUNYAN STREAM ///////////////////////////////////////////////////////////////

class BunyanStream extends Writable {
	constructor(opts) {
		super({
			objectMode: true,
			highWaterMark: opts.bufferSize || defaults.bufferSize
		});

		opts = _.clone(opts || {});

		opts.timestamp = false;
		opts.levels    = opts.levels || defaults.bunyanLevels;

		this[$Logger] = new Logger(opts);

		this[$Logger].on('error', err => this.emit(err));
	}

	@unwritable
	_write(log, enc, cb) {
		const lvl = (log.level / 10) - 1;

		this[$Logger].log(lvl, log);

		setImmediate(cb);
	}
}
